import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../app/store';
import { Octokit } from '@octokit/core';
import { Repository } from './models';


const octokit = new Octokit({
    auth: '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'
})

export interface RepositoriesState {
    repositories: Array<Repository>;
    status: 'idle' | 'loading' | 'failed';
}

const initialState: RepositoriesState = {
    repositories: [],
    status: 'idle',
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.   
export const fetchRepositoriesAsync = createAsyncThunk(
    'counter/fetchRepositories',
    async () => {
        const response = await octokit.request('GET /users/{username}/repos', {
            username: 'manjunath-intercax'
        })
        // await octokit.request('GET /repos/{owner}/{repo}/pulls', {
        //     owner: 'OWNER',
        //     repo: 'REPO' 
        //   })
        // await octokit.request('GET /repos/{owner}/{repo}/pulls/{pull_number}/files', {
        //     owner: 'OWNER',
        //     repo: 'REPO',
        //     pull_number: 3
        //   })
        console.log(response.data, 'data')
        // The value we return becomes the `fulfilled` action payload
        return response.data;
    }
);

export const repoSlice = createSlice({
    name: 'repo',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(fetchRepositoriesAsync.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(fetchRepositoriesAsync.fulfilled, (state, action) => {
                state.status = 'idle';
                state.repositories = JSON.parse(JSON.stringify(action.payload))
            })
            .addCase(fetchRepositoriesAsync.rejected, (state) => {
                state.status = 'failed';
            });
    },
});

export default repoSlice.reducer;
